-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sistema certificado de decisión proposicional basado en polinomios.
--   
--   Sistema certificado de decisión proposicional basado en polinomios.
@package FormulasYpolinomios
@version 0.1.0.0


-- | Código correspondiente al artículo "Sistema certificado de decisión
--   proposicional basado en polinomios" presentado en el CLAI2009
--   (Workshop on Computational Logic and Artificial Intelligence).
module CLAI2009

-- | Los símbolos proposicionales se representan por cadenas.
type SimboloProposicional = String

-- | FProp es el tipo de las fórmulas proposicionales definidas por
--   
--   <ul>
--   <li>T y F son fórmulas</li>
--   <li>Si A es una fórmula, también lo es ¬A.</li>
--   <li>Si A y B son fórmulas, entonces (A ∧ B), (A ∨ B), (A → B) y (A ↔
--   B) también lo son.</li>
--   </ul>
data FProp
T :: FProp
F :: FProp
Atom :: SimboloProposicional -> FProp
Neg :: FProp -> FProp
Conj :: FProp -> FProp -> FProp
Disj :: FProp -> FProp -> FProp
Impl :: FProp -> FProp -> FProp
Equi :: FProp -> FProp -> FProp

-- | Declaración del procedimiento de escritura de fórmulas.

-- | Ejemplo de fórmulas.
p :: FProp

-- | Ejemplo de fórmulas.
q :: FProp

-- | Ejemplo de fórmulas.
r :: FProp

-- | (no f) es la negación de f
no :: FProp -> FProp

-- | (f ∨ g) es la disyunción de f y g.
(∨) :: FProp -> FProp -> FProp
infixr 5 ∨

-- | (f ∧ g) es la conjunción de f y g
(∧) :: FProp -> FProp -> FProp
infixr 4 ∧

-- | (f → g) es la implicación de f a g
(→) :: FProp -> FProp -> FProp
infixr 3 →

-- | (f ↔ g) es la equivalencia entre f y g
(↔) :: FProp -> FProp -> FProp
infixr 2 ↔

-- | FProp es una instancia de Arbitrary. Por ejemplo,
--   
--   <pre>
--   &gt; sample (arbitrary :: Gen FProp)
--   T
--   (no p ∨ (F ∧ F))
--   no r
--   ((q → (T ∧ s)) → F)
--   ((((T → p) ∧ s) → no (q → q)) → s)
--   ((no (r ∨ r) → no (p → s)) ∧ ((p ↔ T) ∧ no (s ↔ F)))
--   (F → s)
--   no no p
--   </pre>

-- | Las interpretaciones son listas de fórmulas atómicas. Las fórmulas de
--   las interpretaciones se suponen verdaderas y las restantes fórmulas
--   atómicas se suponen falsas.
type Interpretacion = [FProp]

-- | (significado f i) es el significado de la fórmula f en la
--   interprestación i. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [r]
--   False
--   
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [p,r]
--   True
--   </pre>
significado :: FProp -> Interpretacion -> Bool

-- | (simbolosPropForm f) es el conjunto formado por todos los símbolos
--   proposicionales que aparecen en f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropForm (p ∧ q → p)
--   [p,q]
--   </pre>
simbolosPropForm :: FProp -> [FProp]

-- | (interpretacionesForm f) es la lista de todas las interpretaciones de
--   la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesForm (p ∧ q → p)
--   [[],[p],[q],[p,q]]
--   </pre>
interpretacionesForm :: FProp -> [Interpretacion]

-- | (esModeloFormula i f) se verifica si la interpretación i es un modelo
--   de la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloFormula [r]   ((p ∨ q) ∧ ((no q) ∨ r))
--   False
--   
--   &gt;&gt;&gt; esModeloFormula [p,r] ((p ∨ q) ∧ ((no q) ∨ r))
--   True
--   </pre>
esModeloFormula :: Interpretacion -> FProp -> Bool

-- | (modelosFormula f) es la lista de todas las interpretaciones de la
--   fórmula f que son modelo de F. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosFormula ((p ∨ q) ∧ ((no q) ∨ r))
--   [[p],[p,r],[q,r],[p,q,r]]
--   </pre>
modelosFormula :: FProp -> [Interpretacion]

-- | (esValida f) se verifica si la fórmula f es válida. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esValida (p → p)
--   True
--   
--   &gt;&gt;&gt; esValida (p → q)
--   False
--   
--   &gt;&gt;&gt; esValida ((p → q) ∨ (q → p))
--   True
--   </pre>
esValida :: FProp -> Bool

-- | (prop_esValida f) se verifica si las siguiente condiciones son
--   equivalentes:
--   
--   <ul>
--   <li>f es válida</li>
--   <li>f es consecuencia del conjunto vacío.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esValida
--   +++ OK, passed 100 tests.
--   </pre>
prop_esValida :: FProp -> Bool

-- | (esInsatisfacible f) se verifica si la fórmula f es insatisfacible.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInsatisfacible (p ∧ (no p))
--   True
--   
--   &gt;&gt;&gt; esInsatisfacible ((p → q) ∧ (q → r))
--   False
--   </pre>
esInsatisfacible :: FProp -> Bool

-- | (esSatisfacible f) se verifica si f es satisfacible. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esSatisfacible (p ∧ (no p))
--   False
--   
--   &gt;&gt;&gt; esSatisfacible ((p → q) ∧ (q → r))
--   True
--   </pre>
esSatisfacible :: FProp -> Bool

-- | (unionGeneral x) es la unión de los conjuntos de la lista de conjuntos
--   x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; unionGeneral []
--   []
--   
--   &gt;&gt;&gt; unionGeneral [[1]]
--   [1]
--   
--   &gt;&gt;&gt; unionGeneral [[1],[1,2],[2,3]]
--   [1,2,3]
--   </pre>
unionGeneral :: Eq a => [[a]] -> [a]

-- | (simbolosPropConj s) es el conjunto de los símbolos proposiciones de
--   s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropConj [p ∧ q → r, p → r]
--   [p,q,r]
--   </pre>
simbolosPropConj :: [FProp] -> [FProp]

-- | (interpretacionesConjunto s) es la lista de las interpretaciones de s.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesConjunto [p → q, q → r]
--   [[],[p],[q],[p,q],[r],[p,r],[q,r],[p,q,r]]
--   </pre>
interpretacionesConjunto :: [FProp] -> [Interpretacion]

-- | (esModeloConjunto i s) se verifica si i es modelo de s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   True
--   
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   False
--   </pre>
esModeloConjunto :: Interpretacion -> [FProp] -> Bool

-- | (modelosConjunto s) es la lista de modelos del conjunto s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   [[p],[p,r],[q,r],[p,q,r]]
--   
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   [[p],[q,r],[p,q,r]]
--   </pre>
modelosConjunto :: [FProp] -> [Interpretacion]

-- | (esConsistente s) se verifica si s es consistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   True
--   
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   False
--   </pre>
esConsistente :: [FProp] -> Bool

-- | (esInconsistente s) se verifica si s es inconsistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   False
--   
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   True
--   </pre>
esInconsistente :: [FProp] -> Bool

-- | (esConsecuencia s f) se verifica si f es consecuencia de s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsecuencia [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; esConsecuencia [p] (p ∧ q)
--   False
--   </pre>
esConsecuencia :: [FProp] -> FProp -> Bool

-- | (prop_esConsecuencia s f) verifica que son equivalentes:
--   
--   <ul>
--   <li>f es consecuencia de s</li>
--   <li>s ∪ {¬f} es inconsistente</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esConsecuencia
--   +++ OK, passed 100 tests.
--   </pre>
prop_esConsecuencia :: [FProp] -> FProp -> Bool

-- | (equivalentes f g) se verifica si las fórmulas f y g son equivalentes.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; equivalentes (p → q) (no p ∨ q)
--   True
--   </pre>
equivalentes :: FProp -> FProp -> Bool

-- | <a>caracteres</a> es un generador de caracteres de letras minúsculas.
--   Por ejemplo,
--   
--   <pre>
--   &gt; sample caracteres
--   <tt>x</tt>
--   <tt>n</tt>
--   <a>r</a>
--   </pre>
caracteres :: Gen Char

-- | Las variables se representan por cadenas.
type Variable = String

-- | <a>variables</a> es un generador de variables de longitud 1 ó 2. Por
--   ejemplo,
--   
--   <pre>
--   &gt; sample variables
--   "h"
--   "yi"
--   "m"
--   </pre>
variables :: Gen String

-- | variables' es un generador de variables de longitud aleatoria, pero no
--   cero. Por ejemplo,
--   
--   <pre>
--   &gt; sample variables'
--   "o"
--   "rte"
--   "tmzeu"
--   </pre>
variables' :: Gen String

-- | Los monomios son productos de variables distintas y se representan por
--   listas ordenadas de variables distintas.
data Monomio
M :: [Variable] -> Monomio

-- | El monomio correspondiente a la lista vacía es el 1 (elemento neutro
--   del producto).
mUno :: Monomio

-- | La condición de que las variables sean distintas y ordenadas no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esMonomio (M ["x1","x3","z"])
--   True
--   
--   &gt;&gt;&gt; esMonomio (M ["x5","x3","z"])
--   False
--   
--   &gt;&gt;&gt; esMonomio (M ["x1","x1","z"])
--   False
--   </pre>
esMonomio :: Monomio -> Bool

-- | Los monomios se escribe incercalando el * entre sus variables. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; M ["xy","z","u"]
--   xy*z*u
--   </pre>

-- | (monomiosN n) es un generador de monomios con el número de variables
--   entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (monomiosN 3)
--   1
--   s
--   e*t
--   hx*w*xn
--   &gt; sample (monomiosN 10)
--   at*b*dy*fq*gv*mx*y*z
--   a*cm*d*f*h*wf*z
--   b*dw*wx*x*y*z
--   </pre>
monomiosN :: Int -> Gen Monomio

-- | monomios es un generador de monomios con el número de variables entre
--   0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
monomios :: Gen Monomio

-- | monomios' es un generador de monomios con un número aleatorio de
--   variables. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios'
--   1
--   kl*o*u
--   bm*d*k*mk
--   </pre>
monomios' :: Gen Monomio

-- | <b>Nota</b>. En lo que sigue usa el generador monomio.
--   
--   prop_MonomiosGeneraMonomios comprueba que el generador de monomios
--   genera monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_MonomiosGeneraMonomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_MonomiosGeneraMonomios :: Monomio -> Bool
data Polinomio
P :: [Monomio] -> Polinomio
cero :: Polinomio
uno :: Polinomio
esPolinomio :: Polinomio -> Bool
polinomiosN :: Int -> Gen Polinomio
polinomios :: Gen Polinomio
polinomios' :: Gen Polinomio
prop_PolinomiosGeneraPolinomios :: Polinomio -> Bool
suma :: Polinomio -> Polinomio -> Polinomio
sumaAux :: [Monomio] -> [Monomio] -> [Monomio]
prop_suma_bien_definida :: Polinomio -> Polinomio -> Bool
prop_suma_conmutativa :: Polinomio -> Polinomio -> Bool
prop_suma_asociativa :: Polinomio -> Polinomio -> Polinomio -> Bool
prop_suma_neutro :: Polinomio -> Bool
prop_suma_simetrico :: Polinomio -> Bool
prop_distributiva :: Polinomio -> Polinomio -> Polinomio -> Bool
productoMM :: Monomio -> Monomio -> Monomio
productoMP :: Monomio -> Polinomio -> Polinomio
producto :: Polinomio -> Polinomio -> Polinomio
prop_prod_bien_definido :: Polinomio -> Polinomio -> Bool
prop_prod_conmutativa :: Polinomio -> Polinomio -> Bool
deriv :: Polinomio -> Variable -> Polinomio
prop_deriv_bien_definida :: Polinomio -> Variable -> Bool
prop_deriv_deriv :: Polinomio -> Variable -> Bool
prop_deriv_suma :: Polinomio -> Polinomio -> Variable -> Bool
prop_deriv_prod :: Polinomio -> Polinomio -> Variable -> Bool
tr :: FProp -> Polinomio
pro_tr_bien_definida :: FProp -> Bool
theta :: Polinomio -> FProp
thetaAux :: [Monomio] -> FProp
theta2 :: Monomio -> FProp
theta2Aux :: [SimboloProposicional] -> FProp
prop_theta_tr :: FProp -> Bool
prop_tr_theta :: Polinomio -> Bool
derivP :: FProp -> SimboloProposicional -> FProp
sustituir :: FProp -> SimboloProposicional -> FProp -> FProp
prop_derivP_sustituir :: FProp -> Bool
variablesProp :: FProp -> [SimboloProposicional]
indep :: Polinomio -> Variable -> Polinomio
delta :: Polinomio -> Polinomio -> Variable -> Polinomio
delta' :: Polinomio -> Polinomio -> Variable -> Polinomio
prop_equiv_delta_delta' :: Polinomio -> Polinomio -> Bool
variablesMon :: Monomio -> [Variable]
variablesPol :: Polinomio -> [Variable]
deltaP :: FProp -> FProp -> SimboloProposicional -> FProp
prop_adecuacion_deltaP :: FProp -> FProp -> Bool
pares :: [a] -> [(a, a)]
derivadas :: [Polinomio] -> Variable -> [Polinomio]
derivadasP :: [FProp] -> SimboloProposicional -> [FProp]
deltaRefutable :: [Polinomio] -> Bool
deltaRefutableP' :: [FProp] -> Bool
prop_def_alt_deltaRefutableP :: [FProp] -> Bool
prop_adecuacion_completitud_deltaP :: [FProp] -> Bool
deltaDemostrable :: [FProp] -> FProp -> Bool
prop_adecuacion_completitud_delta_2 :: [FProp] -> FProp -> Bool
deltaTeorema :: FProp -> Bool
prop_adecuacion_completitud_delta_3 :: FProp -> Bool
deltaRefutableP :: [FProp] -> Bool
deltaRefutableSop :: [Polinomio] -> Bool
deltaRefutableSop' :: [Polinomio] -> [Polinomio] -> Bool
derivadasPolConjunto :: Polinomio -> [Polinomio] -> [Polinomio]
derivadasPolPol :: Polinomio -> Polinomio -> [Polinomio]
prop_deltaRefutableSop :: [Polinomio] -> Bool
deltaRefutablePSop :: [FProp] -> Bool
prop_adecuacion_completitud_deltaPSop :: [FProp] -> Bool
palomar :: [FProp]
instance GHC.Classes.Ord CLAI2009.Polinomio
instance GHC.Classes.Eq CLAI2009.Polinomio
instance GHC.Classes.Ord CLAI2009.Monomio
instance GHC.Classes.Eq CLAI2009.Monomio
instance GHC.Classes.Ord CLAI2009.FProp
instance GHC.Classes.Eq CLAI2009.FProp
instance GHC.Show.Show CLAI2009.FProp
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.FProp
instance GHC.Show.Show CLAI2009.Monomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Monomio
instance GHC.Show.Show CLAI2009.Polinomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Polinomio
instance GHC.Num.Num CLAI2009.Polinomio
