-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sistema certificado de decisión proposicional basado en polinomios.
--   
--   Sistema certificado de decisión proposicional basado en polinomios.
@package FormulasYpolinomios
@version 0.1.0.0


-- | Código correspondiente al artículo "Sistema certificado de decisión
--   proposicional basado en polinomios" presentado en el CLAI2009
--   (Workshop on Computational Logic and Artificial Intelligence).
module CLAI2009

-- | Los símbolos proposicionales se representan por cadenas.
type SimboloProposicional = String

-- | FProp es el tipo de las fórmulas proposicionales definidas por
--   
--   <ul>
--   <li>T y F son fórmulas</li>
--   <li>Si A es una fórmula, también lo es ¬A.</li>
--   <li>Si A y B son fórmulas, entonces (A ∧ B), (A ∨ B), (A → B) y (A ↔
--   B) también lo son.</li>
--   </ul>
data FProp
T :: FProp
F :: FProp
Atom :: SimboloProposicional -> FProp
Neg :: FProp -> FProp
Conj :: FProp -> FProp -> FProp
Disj :: FProp -> FProp -> FProp
Impl :: FProp -> FProp -> FProp
Equi :: FProp -> FProp -> FProp

-- | Declaración del procedimiento de escritura de fórmulas.

-- | Ejemplo de fórmulas.
p :: FProp

-- | Ejemplo de fórmulas.
q :: FProp

-- | Ejemplo de fórmulas.
r :: FProp

-- | (no f) es la negación de f
no :: FProp -> FProp

-- | (f ∨ g) es la disyunción de f y g.
(∨) :: FProp -> FProp -> FProp
infixr 5 ∨

-- | (f ∧ g) es la conjunción de f y g
(∧) :: FProp -> FProp -> FProp
infixr 4 ∧

-- | (f → g) es la implicación de f a g
(→) :: FProp -> FProp -> FProp
infixr 3 →

-- | (f ↔ g) es la equivalencia entre f y g
(↔) :: FProp -> FProp -> FProp
infixr 2 ↔

-- | FProp es una instancia de Arbitrary. Por ejemplo,
--   
--   <pre>
--   &gt; sample (arbitrary :: Gen FProp)
--   T
--   (no p ∨ (F ∧ F))
--   no r
--   ((q → (T ∧ s)) → F)
--   ((((T → p) ∧ s) → no (q → q)) → s)
--   ((no (r ∨ r) → no (p → s)) ∧ ((p ↔ T) ∧ no (s ↔ F)))
--   (F → s)
--   no no p
--   </pre>

-- | Las interpretaciones son listas de fórmulas atómicas. Las fórmulas de
--   las interpretaciones se suponen verdaderas y las restantes fórmulas
--   atómicas se suponen falsas.
type Interpretacion = [FProp]

-- | (significado f i) es el significado de la fórmula f en la
--   interprestación i. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [r]
--   False
--   
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [p,r]
--   True
--   </pre>
significado :: FProp -> Interpretacion -> Bool

-- | (simbolosPropForm f) es el conjunto formado por todos los símbolos
--   proposicionales que aparecen en f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropForm (p ∧ q → p)
--   [p,q]
--   </pre>
simbolosPropForm :: FProp -> [FProp]

-- | (interpretacionesForm f) es la lista de todas las interpretaciones de
--   la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesForm (p ∧ q → p)
--   [[],[p],[q],[p,q]]
--   </pre>
interpretacionesForm :: FProp -> [Interpretacion]

-- | (esModeloFormula i f) se verifica si la interpretación i es un modelo
--   de la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloFormula [r]   ((p ∨ q) ∧ ((no q) ∨ r))
--   False
--   
--   &gt;&gt;&gt; esModeloFormula [p,r] ((p ∨ q) ∧ ((no q) ∨ r))
--   True
--   </pre>
esModeloFormula :: Interpretacion -> FProp -> Bool

-- | (modelosFormula f) es la lista de todas las interpretaciones de la
--   fórmula f que son modelo de F. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosFormula ((p ∨ q) ∧ ((no q) ∨ r))
--   [[p],[p,r],[q,r],[p,q,r]]
--   </pre>
modelosFormula :: FProp -> [Interpretacion]

-- | (esValida f) se verifica si la fórmula f es válida. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esValida (p → p)
--   True
--   
--   &gt;&gt;&gt; esValida (p → q)
--   False
--   
--   &gt;&gt;&gt; esValida ((p → q) ∨ (q → p))
--   True
--   </pre>
esValida :: FProp -> Bool

-- | (prop_esValida f) se verifica si las siguiente condiciones son
--   equivalentes:
--   
--   <ul>
--   <li>f es válida</li>
--   <li>f es consecuencia del conjunto vacío.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esValida
--   +++ OK, passed 100 tests.
--   </pre>
prop_esValida :: FProp -> Bool

-- | (esInsatisfacible f) se verifica si la fórmula f es insatisfacible.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInsatisfacible (p ∧ (no p))
--   True
--   
--   &gt;&gt;&gt; esInsatisfacible ((p → q) ∧ (q → r))
--   False
--   </pre>
esInsatisfacible :: FProp -> Bool

-- | (esSatisfacible f) se verifica si f es satisfacible. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esSatisfacible (p ∧ (no p))
--   False
--   
--   &gt;&gt;&gt; esSatisfacible ((p → q) ∧ (q → r))
--   True
--   </pre>
esSatisfacible :: FProp -> Bool

-- | (unionGeneral x) es la unión de los conjuntos de la lista de conjuntos
--   x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; unionGeneral []
--   []
--   
--   &gt;&gt;&gt; unionGeneral [[1]]
--   [1]
--   
--   &gt;&gt;&gt; unionGeneral [[1],[1,2],[2,3]]
--   [1,2,3]
--   </pre>
unionGeneral :: Eq a => [[a]] -> [a]

-- | (simbolosPropConj s) es el conjunto de los símbolos proposiciones de
--   s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropConj [p ∧ q → r, p → r]
--   [p,q,r]
--   </pre>
simbolosPropConj :: [FProp] -> [FProp]

-- | (interpretacionesConjunto s) es la lista de las interpretaciones de s.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesConjunto [p → q, q → r]
--   [[],[p],[q],[p,q],[r],[p,r],[q,r],[p,q,r]]
--   </pre>
interpretacionesConjunto :: [FProp] -> [Interpretacion]

-- | (esModeloConjunto i s) se verifica si i es modelo de s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   True
--   
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   False
--   </pre>
esModeloConjunto :: Interpretacion -> [FProp] -> Bool

-- | (modelosConjunto s) es la lista de modelos del conjunto s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   [[p],[p,r],[q,r],[p,q,r]]
--   
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   [[p],[q,r],[p,q,r]]
--   </pre>
modelosConjunto :: [FProp] -> [Interpretacion]

-- | (esConsistente s) se verifica si s es consistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   True
--   
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   False
--   </pre>
esConsistente :: [FProp] -> Bool

-- | (esInconsistente s) se verifica si s es inconsistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   False
--   
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   True
--   </pre>
esInconsistente :: [FProp] -> Bool

-- | (esConsecuencia s f) se verifica si f es consecuencia de s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsecuencia [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; esConsecuencia [p] (p ∧ q)
--   False
--   </pre>
esConsecuencia :: [FProp] -> FProp -> Bool

-- | (prop_esConsecuencia s f) verifica que son equivalentes:
--   
--   <ul>
--   <li>f es consecuencia de s</li>
--   <li>s ∪ {¬f} es inconsistente</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esConsecuencia
--   +++ OK, passed 100 tests.
--   </pre>
prop_esConsecuencia :: [FProp] -> FProp -> Bool

-- | (equivalentes f g) se verifica si las fórmulas f y g son equivalentes.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; equivalentes (p → q) (no p ∨ q)
--   True
--   </pre>
equivalentes :: FProp -> FProp -> Bool

-- | <a>caracteres</a> es un generador de caracteres de letras minúsculas.
--   Por ejemplo,
--   
--   <pre>
--   &gt; sample caracteres
--   <tt>x</tt>
--   <tt>n</tt>
--   <a>r</a>
--   </pre>
caracteres :: Gen Char

-- | Las variables se representan por cadenas.
type Variable = String

-- | <a>variables</a> es un generador de variables de longitud 1 ó 2. Por
--   ejemplo,
--   
--   <pre>
--   &gt; sample variables
--   "h"
--   "yi"
--   "m"
--   </pre>
variables :: Gen String

-- | variables' es un generador de variables de longitud aleatoria, pero no
--   cero. Por ejemplo,
--   
--   <pre>
--   &gt; sample variables'
--   "o"
--   "rte"
--   "tmzeu"
--   </pre>
variables' :: Gen String

-- | Los monomios son productos de variables distintas y se representan por
--   listas ordenadas de variables distintas.
data Monomio
M :: [Variable] -> Monomio

-- | Los monomios se escribe incercalando el * entre sus variables. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; M []
--   1
--   
--   &gt;&gt;&gt; M ["x"]
--   x
--   
--   &gt;&gt;&gt; M ["xy","z","u"]
--   xy*z*u
--   </pre>

-- | El monomio correspondiente a la lista vacía es el 1 (elemento neutro
--   del producto).
--   
--   <pre>
--   &gt;&gt;&gt; mUno
--   1
--   </pre>
mUno :: Monomio

-- | La condición de que las variables sean distintas y ordenadas no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esMonomio (M ["x1","x3","z"])
--   True
--   
--   &gt;&gt;&gt; esMonomio (M ["x5","x3","z"])
--   False
--   
--   &gt;&gt;&gt; esMonomio (M ["x1","x1","z"])
--   False
--   </pre>
esMonomio :: Monomio -> Bool

-- | (monomiosN n) es un generador de monomios con el número de variables
--   entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (monomiosN 3)
--   1
--   s
--   e*t
--   hx*w*xn
--   &gt; sample (monomiosN 10)
--   at*b*dy*fq*gv*mx*y*z
--   a*cm*d*f*h*wf*z
--   b*dw*wx*x*y*z
--   </pre>
monomiosN :: Int -> Gen Monomio

-- | monomios es un generador de monomios con el número de variables entre
--   0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
monomios :: Gen Monomio

-- | monomios' es un generador de monomios con un número aleatorio de
--   variables. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios'
--   1
--   kl*o*u
--   bm*d*k*mk
--   </pre>
monomios' :: Gen Monomio

-- | prop_MonomiosGeneraMonomios comprueba que el generador de monomios
--   genera monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_MonomiosGeneraMonomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_MonomiosGeneraMonomios :: Monomio -> Bool

-- | Los polinomios son sumas de monomios distintos y ordenados y se
--   representan por listas ordenadas de monomios distintos,
data Polinomio
P :: [Monomio] -> Polinomio

-- | Los polinomios se escribe incercalando el + entre sus monomios. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; P [M ["xy","z","u"], M ["p","q"]]
--   xy*z*u+p*q
--   
--   &gt;&gt;&gt; P [M ["xy","z","u"]]
--   xy*z*u
--   
--   &gt;&gt;&gt; P [M []]
--   1
--   
--   &gt;&gt;&gt; P []
--   0
--   </pre>

-- | El polinomio correspondiente a la lista vacía es el 0 (elemento neutro
--   de la suma). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; cero
--   0
--   </pre>
cero :: Polinomio

-- | El polinomio 1 es el polinomio cuyo único elemento es el monomio uno.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; uno
--   1
--   </pre>
uno :: Polinomio

-- | La condición de que los monomios sean distintos y ordenados no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esPolinomio (P [M ["a","b","c"], M ["x","y"]])
--   True
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","d","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","a","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["a","a","c"], M ["x","y"]])
--   False
--   </pre>
esPolinomio :: Polinomio -> Bool

-- | (polinomiosN n) es un generador de polinomios con el número de
--   monomios entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (polinomiosN 3)
--   0
--   pp*sa
--   gn*nf*zg
--   &gt; sample (polinomiosN 10)
--   1+b*j+gw*w*zm+j*ox+l*q*qz+ly*p*r+m+q*zy
--   iz
--   1+d+dy+jd*l+lr+w
--   </pre>
polinomiosN :: Int -> Gen Polinomio

-- | polinomios es un generador de polinomios con el número de monomios
--   entre 0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
polinomios :: Gen Polinomio

-- | polinomios' es un generador de polinomios con un número aleatorio de
--   monomios. Por ejemplo,
--   
--   <pre>
--   &gt; sample polinomios'
--   0
--   1
--   f*m*on*tr*ue*x
--   ct*d*ds*gy*ps*s*y
--   </pre>
polinomios' :: Gen Polinomio

-- | prop_PolinomiosGeneraPolinomios comprueba que el generador de
--   polinomios genera polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_PolinomiosGeneraPolinomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_PolinomiosGeneraPolinomios :: Polinomio -> Bool

-- | (suma p q) es la suma de los polinomios p y q. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["y"], M ["z"]])
--   x+z
--   
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["a"], M ["z"]])
--   a+x+y+z
--   </pre>
suma :: Polinomio -> Polinomio -> Polinomio

-- | (sumaAux xs ys) es la lista de las sumas de los monomios de xs e ys.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["y"], M ["z"]]
--   [x,z]
--   
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["a"], M ["z"]]
--   [a,x,y,z]
--   </pre>
sumaAux :: [Monomio] -> [Monomio] -> [Monomio]

-- | Comprueba que la suma de polinomios está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_bien_definida :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_asociativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_asociativa :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | Comprueba que cero es el elemento neutro de la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_neutro
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_neutro :: Polinomio -> Bool

-- | Comprueba que cada elemento es su simétrico en la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_simetrico
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_simetrico :: Polinomio -> Bool

-- | (productoMM m1 m2) es el producto de los monomios m1 y m2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMM (M ["x","y"]) (M ["y","z"])
--   x*y*z
--   </pre>
productoMM :: Monomio -> Monomio -> Monomio

-- | (productoMP m p) es el producto del monomio m por el polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMP (M ["x","y"]) (P [M ["a"], M ["y","z"]])
--   a*x*y+x*y*z
--   </pre>
productoMP :: Monomio -> Polinomio -> Polinomio

-- | (producto p1 p2) es el producto de los polinomios p1 y p2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["a"], M ["y","z"]])
--   a*x*y+a*z+x*y*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["x"], M ["y","z"]])
--   x*y+x*y*z+x*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x"], M ["y"]]) (P [M ["x"], M ["y"]])
--   x+y
--   </pre>
producto :: Polinomio -> Polinomio -> Polinomio

-- | Comprueba que el producto de polinomios está bien definido.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_bien_definido
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_bien_definido :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es conmutativo
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es distributivo respecto de la
--   suma.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_distributiva
--   +++ OK, passed 100 tests.
--   </pre>
prop_distributiva :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | (deriv p x) es la derivada del polinomio p respecto de la variable x;
--   es decir, la lista de monomios de p que contienen la variable x,
--   eliminándola. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deriv (P [M ["u"],M ["x"],M ["x","y"],M ["x","z"]]) "x"
--   1+y+z
--   </pre>
deriv :: Polinomio -> Variable -> Polinomio

-- | Comprueba que la derivada está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_bien_definida :: Polinomio -> Variable -> Bool

-- | Comprueba que la segunda derivada es nula.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_deriv
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_deriv :: Polinomio -> Variable -> Bool

-- | Comprueba que la derivada de la suma es la suma de las derivadas.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_suma
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_suma :: Polinomio -> Polinomio -> Variable -> Bool

-- | Comprueba que la regla de la derivada del producto
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_prod
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_prod :: Polinomio -> Polinomio -> Variable -> Bool

-- | (tr f) es el polinomio correspondiente a la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; tr (p ∧ (q ∨ r))
--   p*q+p*q*r+p*r
--   
--   &gt;&gt;&gt; tr (p → p ∨ q)
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → p))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → r))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (r → q))
--   1+p*q*r+p*r
--   </pre>
tr :: FProp -> Polinomio

-- | Comprueba que, para toda fórmula f, (tr f) es un polinomio.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck pro_tr_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
pro_tr_bien_definida :: FProp -> Bool

-- | (theta2 m) es la fórmula correspondiente al polinomio p según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta 0 = F</li>
--   <li>theta (a+b) = no ((theta a) ↔ (theta b))</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta (P [mUno])
--   ⊤
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"]])
--   ¬(⊤ ↔ p)
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"]])
--   ¬(⊤ ↔ ¬(p ↔ (p ∧ q)))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ (p ∧ (q ∧ r)))))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"],M["r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ ¬((p ∧ (q ∧ r)) ↔ r))))
--   </pre>
theta :: Polinomio -> FProp

-- | (theta2 m) es la fórmula correspondiente al monomio m según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta2 1 = T</li>
--   <li>theta2 (x_i) = p_i</li>
--   <li>theta2 (a*b) = (theta2 a) ∧ (theta2 b)</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta2 (M ["p","q","r"])
--   (p ∧ (q ∧ r))
--   </pre>
theta2 :: Monomio -> FProp

-- | Comprueba que para cualquier fórmula f, (theta (tr f)) es equivalente
--   a f.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_theta_tr
--   +++ OK, passed 100 tests.
--   </pre>
prop_theta_tr :: FProp -> Bool

-- | Comprueba que, para cualquier polinomio p, tr (theta p) es igual a p.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_tr_theta
--   +++ OK, passed 100 tests.
--   </pre>
prop_tr_theta :: Polinomio -> Bool

-- | (derivP f v) es la derivada de la fórmula proposicional f respecto de
--   la variable v. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivP (p ∧ q → r) "p"
--   ¬(q ↔ (q ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "q"
--   ¬(p ↔ (p ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "r"
--   (p ∧ q)
--   
--   &gt;&gt;&gt; derivP (p ∧ q → p ∨ q) "p"
--   ⊥
--   </pre>
derivP :: FProp -> SimboloProposicional -> FProp

-- | (sustituir f v g) es la fórmula obtenida sustituyendo en la fórmula f
--   la variable v por la fórmula g. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sustituir (p → q ∨ r) "q" (p ∧ q)
--   (p → ((p ∧ q) ∨ r))
--   </pre>
sustituir :: FProp -> SimboloProposicional -> FProp -> FProp

-- | (variablesProp f) es la lista de las variables proposicionales de la
--   fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesProp (p → q ∨ p)
--   ["p","q"]
--   </pre>
variablesProp :: FProp -> [SimboloProposicional]

-- | Comprueba que, para toda fórmula f y toda variable x de f, la derivada
--   de f respecto de x es equivalente a la fórmula ¬(f[x/¬x] ↔ f)
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_derivP_sustituir
--   +++ OK, passed 100 tests.
--   </pre>
prop_derivP_sustituir :: FProp -> Bool
indep :: Polinomio -> Variable -> Polinomio
delta :: Polinomio -> Polinomio -> Variable -> Polinomio
delta' :: Polinomio -> Polinomio -> Variable -> Polinomio
prop_equiv_delta_delta' :: Polinomio -> Polinomio -> Bool
variablesMon :: Monomio -> [Variable]
variablesPol :: Polinomio -> [Variable]
deltaP :: FProp -> FProp -> SimboloProposicional -> FProp
prop_adecuacion_deltaP :: FProp -> FProp -> Bool
pares :: [a] -> [(a, a)]
derivadas :: [Polinomio] -> Variable -> [Polinomio]
derivadasP :: [FProp] -> SimboloProposicional -> [FProp]
deltaRefutable :: [Polinomio] -> Bool
deltaRefutableP' :: [FProp] -> Bool
prop_def_alt_deltaRefutableP :: [FProp] -> Bool
prop_adecuacion_completitud_deltaP :: [FProp] -> Bool
deltaDemostrable :: [FProp] -> FProp -> Bool
prop_adecuacion_completitud_delta_2 :: [FProp] -> FProp -> Bool
deltaTeorema :: FProp -> Bool
prop_adecuacion_completitud_delta_3 :: FProp -> Bool
deltaRefutableP :: [FProp] -> Bool
deltaRefutableSop :: [Polinomio] -> Bool
deltaRefutableSop' :: [Polinomio] -> [Polinomio] -> Bool
derivadasPolConjunto :: Polinomio -> [Polinomio] -> [Polinomio]
derivadasPolPol :: Polinomio -> Polinomio -> [Polinomio]
prop_deltaRefutableSop :: [Polinomio] -> Bool
deltaRefutablePSop :: [FProp] -> Bool
prop_adecuacion_completitud_deltaPSop :: [FProp] -> Bool
palomar :: [FProp]
instance GHC.Classes.Ord CLAI2009.Polinomio
instance GHC.Classes.Eq CLAI2009.Polinomio
instance GHC.Classes.Ord CLAI2009.Monomio
instance GHC.Classes.Eq CLAI2009.Monomio
instance GHC.Classes.Ord CLAI2009.FProp
instance GHC.Classes.Eq CLAI2009.FProp
instance GHC.Show.Show CLAI2009.FProp
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.FProp
instance GHC.Show.Show CLAI2009.Monomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Monomio
instance GHC.Show.Show CLAI2009.Polinomio
instance Test.QuickCheck.Arbitrary.Arbitrary CLAI2009.Polinomio
instance GHC.Num.Num CLAI2009.Polinomio
