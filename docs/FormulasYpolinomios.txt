-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sistema certificado de decisión proposicional basado en polinomios.
--   
--   Sistema de decisión proposicional basado en la transformación de
--   fórmulas a polinomios y usando la regla de independencia. Las
--   propiedades están verificadas con QuickCheck.
--   
--   El código se describe en el artículo <a>Sistema certificado de
--   decisión proposicional basado en polinomios</a> presentado en el
--   CLAI2009 (Workshop on Computational Logic and Artificial
--   Intelligence).
--   
--   El orden de lectura de los módulos es el siguiente:
--   
--   <ul>
--   <li><a>Logica</a>: Lógica proposicional.</li>
--   <li><a>PolinomiosF2</a>: Polinomios en Z2/(x1^1-x1,...,xn^2-xn).</li>
--   <li><a>Transformaciones</a>: Transformaciones entre fórmulas y
--   polinomios.</li>
--   <li><a>DeltaDeduccion</a>: Deducción con la regla delta (o de la
--   independencia).</li>
--   </ul>
@package FormulasYpolinomios
@version 0.1.0.0

module PolinomiosF2

-- | <a>caracteres</a> es un generador de caracteres de letras minúsculas.
--   Por ejemplo,
--   
--   <pre>
--   &gt; sample caracteres
--   <tt>x</tt>
--   <tt>n</tt>
--   <tt>r</tt>
--   </pre>
caracteres :: Gen Char

-- | Las variables se representan por cadenas.
type Variable = String

-- | <a>variables</a> es un generador de variables de longitud 1 ó 2. Por
--   ejemplo,
--   
--   <pre>
--   &gt; sample variables
--   "h"
--   "yi"
--   "m"
--   </pre>
variables :: Gen String

-- | variables' es un generador de variables de longitud aleatoria, pero no
--   cero. Por ejemplo,
--   
--   <pre>
--   &gt; sample variables'
--   "o"
--   "rte"
--   "tmzeu"
--   </pre>
variables' :: Gen String

-- | Los monomios son productos de variables distintas y se representan por
--   listas ordenadas de variables distintas.
data Monomio
M :: [Variable] -> Monomio

-- | Los monomios se escribe incercalando el * entre sus variables. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; M []
--   1
--   
--   &gt;&gt;&gt; M ["x"]
--   x
--   
--   &gt;&gt;&gt; M ["xy","z","u"]
--   xy*z*u
--   </pre>

-- | El monomio correspondiente a la lista vacía es el 1 (elemento neutro
--   del producto).
--   
--   <pre>
--   &gt;&gt;&gt; mUno
--   1
--   </pre>
mUno :: Monomio

-- | La condición de que las variables sean distintas y ordenadas no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esMonomio (M ["x1","x3","z"])
--   True
--   
--   &gt;&gt;&gt; esMonomio (M ["x5","x3","z"])
--   False
--   
--   &gt;&gt;&gt; esMonomio (M ["x1","x1","z"])
--   False
--   </pre>
esMonomio :: Monomio -> Bool

-- | (monomiosN n) es un generador de monomios con el número de variables
--   entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (monomiosN 3)
--   1
--   s
--   e*t
--   hx*w*xn
--   &gt; sample (monomiosN 10)
--   at*b*dy*fq*gv*mx*y*z
--   a*cm*d*f*h*wf*z
--   b*dw*wx*x*y*z
--   </pre>
monomiosN :: Int -> Gen Monomio

-- | monomios es un generador de monomios con el número de variables entre
--   0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
monomios :: Gen Monomio

-- | monomios' es un generador de monomios con un número aleatorio de
--   variables. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios'
--   1
--   kl*o*u
--   bm*d*k*mk
--   </pre>
monomios' :: Gen Monomio

-- | prop_MonomiosGeneraMonomios comprueba que el generador de monomios
--   genera monomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_MonomiosGeneraMonomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_MonomiosGeneraMonomios :: Monomio -> Bool

-- | Los monomios son arbitrarios.

-- | Los polinomios son sumas de monomios distintos y ordenados y se
--   representan por listas ordenadas de monomios distintos,
data Polinomio
P :: [Monomio] -> Polinomio

-- | Los polinomios se escribe incercalando el + entre sus monomios. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; P [M ["xy","z","u"], M ["p","q"]]
--   xy*z*u+p*q
--   
--   &gt;&gt;&gt; P [M ["xy","z","u"]]
--   xy*z*u
--   
--   &gt;&gt;&gt; P [M []]
--   1
--   
--   &gt;&gt;&gt; P []
--   0
--   </pre>

-- | El polinomio correspondiente a la lista vacía es el 0 (elemento neutro
--   de la suma). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; cero
--   0
--   </pre>
cero :: Polinomio

-- | El polinomio 1 es el polinomio cuyo único elemento es el monomio uno.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; uno
--   1
--   </pre>
uno :: Polinomio

-- | La condición de que los monomios sean distintos y ordenados no se
--   recoge en la definición del tipo de dato. Por ello se define el
--   siguiente reconocedor de polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esPolinomio (P [M ["a","b","c"], M ["x","y"]])
--   True
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","d","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["a","a","c"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["x","y"], M ["x","y"], M ["a","c","d"]])
--   False
--   
--   &gt;&gt;&gt; esPolinomio (P [M ["a","a","c"], M ["x","y"]])
--   False
--   </pre>
esPolinomio :: Polinomio -> Bool

-- | (polinomiosN n) es un generador de polinomios con el número de
--   monomios entre 0 y n. Por ejemplo,
--   
--   <pre>
--   &gt; sample (polinomiosN 3)
--   0
--   pp*sa
--   gn*nf*zg
--   &gt; sample (polinomiosN 10)
--   1+b*j+gw*w*zm+j*ox+l*q*qz+ly*p*r+m+q*zy
--   iz
--   1+d+dy+jd*l+lr+w
--   </pre>
polinomiosN :: Int -> Gen Polinomio

-- | polinomios es un generador de polinomios con el número de monomios
--   entre 0 y 3. Por ejemplo,
--   
--   <pre>
--   &gt; sample monomios
--   nd*q
--   e
--   1
--   </pre>
polinomios :: Gen Polinomio

-- | polinomios' es un generador de polinomios con un número aleatorio de
--   monomios. Por ejemplo,
--   
--   <pre>
--   &gt; sample polinomios'
--   0
--   1
--   f*m*on*tr*ue*x
--   ct*d*ds*gy*ps*s*y
--   </pre>
polinomios' :: Gen Polinomio

-- | prop_PolinomiosGeneraPolinomios comprueba que el generador de
--   polinomios genera polinomios. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_PolinomiosGeneraPolinomios
--   +++ OK, passed 100 tests.
--   </pre>
prop_PolinomiosGeneraPolinomios :: Polinomio -> Bool

-- | Los polinomios son arbitrarios.

-- | Para facilitar la escritura, se hace Polinomio una instancia de la
--   clase Num. Las funciones suma y producto se definen a continuación.

-- | (suma p q) es la suma de los polinomios p y q. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["y"], M ["z"]])
--   x+z
--   
--   &gt;&gt;&gt; suma (P [M ["x"], M ["y"]]) (P [M ["a"], M ["z"]])
--   a+x+y+z
--   </pre>
suma :: Polinomio -> Polinomio -> Polinomio

-- | (sumaAux xs ys) es la lista de las sumas de los monomios de xs e ys.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["y"], M ["z"]]
--   [x,z]
--   
--   &gt;&gt;&gt; sumaAux [M ["x"], M ["y"]] [M ["a"], M ["z"]]
--   [a,x,y,z]
--   </pre>
sumaAux :: [Monomio] -> [Monomio] -> [Monomio]

-- | Comprueba que la suma de polinomios está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_bien_definida :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que la suma de polinomios es conmutativa.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_asociativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_asociativa :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | Comprueba que cero es el elemento neutro de la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_neutro
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_neutro :: Polinomio -> Bool

-- | Comprueba que cada elemento es su simétrico en la suma de polinomios.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_suma_simetrico
--   +++ OK, passed 100 tests.
--   </pre>
prop_suma_simetrico :: Polinomio -> Bool

-- | (productoMM m1 m2) es el producto de los monomios m1 y m2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMM (M ["x","y"]) (M ["y","z"])
--   x*y*z
--   </pre>
productoMM :: Monomio -> Monomio -> Monomio

-- | (productoMP m p) es el producto del monomio m por el polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; productoMP (M ["x","y"]) (P [M ["a"], M ["y","z"]])
--   a*x*y+x*y*z
--   </pre>
productoMP :: Monomio -> Polinomio -> Polinomio

-- | (producto p1 p2) es el producto de los polinomios p1 y p2. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["a"], M ["y","z"]])
--   a*x*y+a*z+x*y*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x","y"], M ["z"]]) (P [M ["x"], M ["y","z"]])
--   x*y+x*y*z+x*z+y*z
--   
--   &gt;&gt;&gt; producto (P [M ["x"], M ["y"]]) (P [M ["x"], M ["y"]])
--   x+y
--   </pre>
producto :: Polinomio -> Polinomio -> Polinomio

-- | Comprueba que el producto de polinomios está bien definido.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_bien_definido
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_bien_definido :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es conmutativo
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_prod_conmutativa
--   +++ OK, passed 100 tests.
--   </pre>
prop_prod_conmutativa :: Polinomio -> Polinomio -> Bool

-- | Comprueba que el producto de polinomios es distributivo respecto de la
--   suma.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_distributiva
--   +++ OK, passed 100 tests.
--   </pre>
prop_distributiva :: Polinomio -> Polinomio -> Polinomio -> Bool

-- | (deriv p x) es la derivada del polinomio p respecto de la variable x;
--   es decir, la lista de monomios de p que contienen la variable x,
--   eliminándola. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deriv (P [M ["u"],M ["x"],M ["x","y"],M ["x","z"]]) "x"
--   1+y+z
--   </pre>
deriv :: Polinomio -> Variable -> Polinomio

-- | Comprueba que la derivada está bien definida.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_bien_definida :: Polinomio -> Variable -> Bool

-- | Comprueba que la segunda derivada es nula.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_deriv
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_deriv :: Polinomio -> Variable -> Bool

-- | Comprueba que la derivada de la suma es la suma de las derivadas.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_suma
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_suma :: Polinomio -> Polinomio -> Variable -> Bool

-- | Comprueba que la regla de la derivada del producto
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_deriv_prod
--   +++ OK, passed 100 tests.
--   </pre>
prop_deriv_prod :: Polinomio -> Polinomio -> Variable -> Bool
instance GHC.Classes.Ord PolinomiosF2.Polinomio
instance GHC.Classes.Eq PolinomiosF2.Polinomio
instance GHC.Classes.Ord PolinomiosF2.Monomio
instance GHC.Classes.Eq PolinomiosF2.Monomio
instance GHC.Show.Show PolinomiosF2.Monomio
instance Test.QuickCheck.Arbitrary.Arbitrary PolinomiosF2.Monomio
instance GHC.Show.Show PolinomiosF2.Polinomio
instance Test.QuickCheck.Arbitrary.Arbitrary PolinomiosF2.Polinomio
instance GHC.Num.Num PolinomiosF2.Polinomio

module Logica

-- | Los símbolos proposicionales se representan por cadenas.
type SimboloProposicional = String

-- | FProp es el tipo de las fórmulas proposicionales definidas por
--   
--   <ul>
--   <li>T y F son fórmulas</li>
--   <li>Si A es una fórmula, también lo es ¬A.</li>
--   <li>Si A y B son fórmulas, entonces (A ∧ B), (A ∨ B), (A → B) y (A ↔
--   B) también lo son.</li>
--   </ul>
data FProp
T :: FProp
F :: FProp
Atom :: SimboloProposicional -> FProp
Neg :: FProp -> FProp
Conj :: FProp -> FProp -> FProp
Disj :: FProp -> FProp -> FProp
Impl :: FProp -> FProp -> FProp
Equi :: FProp -> FProp -> FProp

-- | Declaración del procedimiento de escritura de fórmulas.

-- | Ejemplo de fórmulas.
p :: FProp

-- | Ejemplo de fórmulas.
q :: FProp

-- | Ejemplo de fórmulas.
r :: FProp

-- | (no f) es la negación de f
no :: FProp -> FProp

-- | (f ∨ g) es la disyunción de f y g.
(∨) :: FProp -> FProp -> FProp
infixr 5 ∨

-- | (f ∧ g) es la conjunción de f y g
(∧) :: FProp -> FProp -> FProp
infixr 4 ∧

-- | (f → g) es la implicación de f a g
(→) :: FProp -> FProp -> FProp
infixr 3 →

-- | (f ↔ g) es la equivalencia entre f y g
(↔) :: FProp -> FProp -> FProp
infixr 2 ↔

-- | FProp es una instancia de Arbitrary. Por ejemplo,
--   
--   <pre>
--   &gt; sample (arbitrary :: Gen FProp)
--   T
--   (no p ∨ (F ∧ F))
--   no r
--   ((q → (T ∧ s)) → F)
--   ((((T → p) ∧ s) → no (q → q)) → s)
--   ((no (r ∨ r) → no (p → s)) ∧ ((p ↔ T) ∧ no (s ↔ F)))
--   (F → s)
--   no no p
--   </pre>

-- | Las interpretaciones son listas de fórmulas atómicas. Las fórmulas de
--   las interpretaciones se suponen verdaderas y las restantes fórmulas
--   atómicas se suponen falsas.
type Interpretacion = [FProp]

-- | (significado f i) es el significado de la fórmula f en la
--   interprestación i. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [r]
--   False
--   
--   &gt;&gt;&gt; significado ((p ∨ q) ∧ ((no q) ∨ r)) [p,r]
--   True
--   </pre>
significado :: FProp -> Interpretacion -> Bool

-- | (simbolosPropForm f) es el conjunto formado por todos los símbolos
--   proposicionales que aparecen en f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropForm (p ∧ q → p)
--   [p,q]
--   </pre>
simbolosPropForm :: FProp -> [FProp]

-- | (interpretacionesForm f) es la lista de todas las interpretaciones de
--   la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesForm (p ∧ q → p)
--   [[],[p],[q],[p,q]]
--   </pre>
interpretacionesForm :: FProp -> [Interpretacion]

-- | (esModeloFormula i f) se verifica si la interpretación i es un modelo
--   de la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloFormula [r]   ((p ∨ q) ∧ ((no q) ∨ r))
--   False
--   
--   &gt;&gt;&gt; esModeloFormula [p,r] ((p ∨ q) ∧ ((no q) ∨ r))
--   True
--   </pre>
esModeloFormula :: Interpretacion -> FProp -> Bool

-- | (modelosFormula f) es la lista de todas las interpretaciones de la
--   fórmula f que son modelo de F. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosFormula ((p ∨ q) ∧ ((no q) ∨ r))
--   [[p],[p,r],[q,r],[p,q,r]]
--   </pre>
modelosFormula :: FProp -> [Interpretacion]

-- | (esValida f) se verifica si la fórmula f es válida. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esValida (p → p)
--   True
--   
--   &gt;&gt;&gt; esValida (p → q)
--   False
--   
--   &gt;&gt;&gt; esValida ((p → q) ∨ (q → p))
--   True
--   </pre>
esValida :: FProp -> Bool

-- | (prop_esValida f) se verifica si las siguiente condiciones son
--   equivalentes:
--   
--   <ul>
--   <li>f es válida</li>
--   <li>f es consecuencia del conjunto vacío.</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esValida
--   +++ OK, passed 100 tests.
--   </pre>
prop_esValida :: FProp -> Bool

-- | (esInsatisfacible f) se verifica si la fórmula f es insatisfacible.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInsatisfacible (p ∧ (no p))
--   True
--   
--   &gt;&gt;&gt; esInsatisfacible ((p → q) ∧ (q → r))
--   False
--   </pre>
esInsatisfacible :: FProp -> Bool

-- | (esSatisfacible f) se verifica si f es satisfacible. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esSatisfacible (p ∧ (no p))
--   False
--   
--   &gt;&gt;&gt; esSatisfacible ((p → q) ∧ (q → r))
--   True
--   </pre>
esSatisfacible :: FProp -> Bool

-- | (unionGeneral x) es la unión de los conjuntos de la lista de conjuntos
--   x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; unionGeneral []
--   []
--   
--   &gt;&gt;&gt; unionGeneral [[1]]
--   [1]
--   
--   &gt;&gt;&gt; unionGeneral [[1],[1,2],[2,3]]
--   [1,2,3]
--   </pre>
unionGeneral :: Eq a => [[a]] -> [a]

-- | (simbolosPropConj s) es el conjunto de los símbolos proposiciones de
--   s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; simbolosPropConj [p ∧ q → r, p → r]
--   [p,q,r]
--   </pre>
simbolosPropConj :: [FProp] -> [FProp]

-- | (interpretacionesConjunto s) es la lista de las interpretaciones de s.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; interpretacionesConjunto [p → q, q → r]
--   [[],[p],[q],[p,q],[r],[p,r],[q,r],[p,q,r]]
--   </pre>
interpretacionesConjunto :: [FProp] -> [Interpretacion]

-- | (esModeloConjunto i s) se verifica si i es modelo de s. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   True
--   
--   &gt;&gt;&gt; esModeloConjunto [p,r] [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   False
--   </pre>
esModeloConjunto :: Interpretacion -> [FProp] -> Bool

-- | (modelosConjunto s) es la lista de modelos del conjunto s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), q → r]
--   [[p],[p,r],[q,r],[p,q,r]]
--   
--   &gt;&gt;&gt; modelosConjunto [(p ∨ q) ∧ ((no q) ∨ r), r → q]
--   [[p],[q,r],[p,q,r]]
--   </pre>
modelosConjunto :: [FProp] -> [Interpretacion]

-- | (esConsistente s) se verifica si s es consistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   True
--   
--   &gt;&gt;&gt; esConsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   False
--   </pre>
esConsistente :: [FProp] -> Bool

-- | (esInconsistente s) se verifica si s es inconsistente. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r]
--   False
--   
--   &gt;&gt;&gt; esInconsistente [(p ∨ q) ∧ ((no q) ∨ r), p → r, no r]
--   True
--   </pre>
esInconsistente :: [FProp] -> Bool

-- | (esConsecuencia s f) se verifica si f es consecuencia de s. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; esConsecuencia [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; esConsecuencia [p] (p ∧ q)
--   False
--   </pre>
esConsecuencia :: [FProp] -> FProp -> Bool

-- | (prop_esConsecuencia s f) verifica que son equivalentes:
--   
--   <ul>
--   <li>f es consecuencia de s</li>
--   <li>s ∪ {¬f} es inconsistente</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_esConsecuencia
--   +++ OK, passed 100 tests.
--   </pre>
prop_esConsecuencia :: [FProp] -> FProp -> Bool

-- | (equivalentes f g) se verifica si las fórmulas f y g son equivalentes.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; equivalentes (p → q) (no p ∨ q)
--   True
--   </pre>
equivalentes :: FProp -> FProp -> Bool
instance GHC.Classes.Ord Logica.FProp
instance GHC.Classes.Eq Logica.FProp
instance GHC.Show.Show Logica.FProp
instance Test.QuickCheck.Arbitrary.Arbitrary Logica.FProp

module Transformaciones

-- | (tr f) es el polinomio correspondiente a la fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; tr (p ∧ (q ∨ r))
--   p*q+p*q*r+p*r
--   
--   &gt;&gt;&gt; tr (p → p ∨ q)
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → p))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (q → r))
--   1
--   
--   &gt;&gt;&gt; tr ((p → q) ∨ (r → q))
--   1+p*q*r+p*r
--   </pre>
tr :: FProp -> Polinomio

-- | Comprueba que, para toda fórmula f, (tr f) es un polinomio.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck pro_tr_bien_definida
--   +++ OK, passed 100 tests.
--   </pre>
pro_tr_bien_definida :: FProp -> Bool

-- | (theta2 m) es la fórmula correspondiente al polinomio p según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta 0 = F</li>
--   <li>theta (a+b) = no ((theta a) ↔ (theta b))</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta (P [mUno])
--   ⊤
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"]])
--   ¬(⊤ ↔ p)
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"]])
--   ¬(⊤ ↔ ¬(p ↔ (p ∧ q)))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ (p ∧ (q ∧ r)))))
--   
--   &gt;&gt;&gt; theta (P [mUno, M ["p"], M ["p","q"],M["p","q","r"],M["r"]])
--   ¬(⊤ ↔ ¬(p ↔ ¬((p ∧ q) ↔ ¬((p ∧ (q ∧ r)) ↔ r))))
--   </pre>
theta :: Polinomio -> FProp

-- | (theta2 m) es la fórmula correspondiente al monomio m según las
--   siguientes reglas:
--   
--   <ul>
--   <li>theta2 1 = T</li>
--   <li>theta2 (x_i) = p_i</li>
--   <li>theta2 (a*b) = (theta2 a) ∧ (theta2 b)</li>
--   </ul>
--   
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; theta2 (M ["p","q","r"])
--   (p ∧ (q ∧ r))
--   </pre>
theta2 :: Monomio -> FProp

-- | Comprueba que para cualquier fórmula f, (theta (tr f)) es equivalente
--   a f.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_theta_tr
--   +++ OK, passed 100 tests.
--   </pre>
prop_theta_tr :: FProp -> Bool

-- | Comprueba que, para cualquier polinomio p, tr (theta p) es igual a p.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_tr_theta
--   +++ OK, passed 100 tests.
--   </pre>
prop_tr_theta :: Polinomio -> Bool

module DeltaDeduccion

-- | (derivP f v) es la derivada de la fórmula proposicional f respecto de
--   la variable v. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivP (p ∧ q → r) "p"
--   ¬(q ↔ (q ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "q"
--   ¬(p ↔ (p ∧ r))
--   
--   &gt;&gt;&gt; derivP (p ∧ q → r) "r"
--   (p ∧ q)
--   
--   &gt;&gt;&gt; derivP (p ∧ q → p ∨ q) "p"
--   ⊥
--   </pre>
derivP :: FProp -> SimboloProposicional -> FProp

-- | (sustituir f v g) es la fórmula obtenida sustituyendo en la fórmula f
--   la variable v por la fórmula g. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; sustituir (p → q ∨ r) "q" (p ∧ q)
--   (p → ((p ∧ q) ∨ r))
--   </pre>
sustituir :: FProp -> SimboloProposicional -> FProp -> FProp

-- | (variablesProp f) es la lista de las variables proposicionales de la
--   fórmula f. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesProp (p → q ∨ p)
--   ["p","q"]
--   </pre>
variablesProp :: FProp -> [SimboloProposicional]

-- | Comprueba que, para toda fórmula f y toda variable x de f, la derivada
--   de f respecto de x es equivalente a la fórmula ¬(f[x/¬x] ↔ f)
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_derivP_sustituir
--   +++ OK, passed 100 tests.
--   </pre>
prop_derivP_sustituir :: FProp -> Bool

-- | (indep p x) es el polinomio formado por los monomios de que no
--   contienen la variable x. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; indep (P[M["x","y"],M["y","u"],M ["z"]]) "x"
--   y*u+z
--   </pre>
indep :: Polinomio -> Variable -> Polinomio

-- | (delta a1 a2 v) es el polinomio obtenido aplicando la regla delta (o
--   de independencia) a los polinomios a1 y a2 respecto de la variable v;
--   es decir, el polinomio 1 + (1+a1*a2)*(1+a1*c2+a2*c1+c1*c2) donde ci es
--   la derivada de ai respecto de v (para i = 1, 2). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; delta (P[M["x","y"],M["y","z"]]) (P[M["u","x"],M["y","z"]]) "x"
--   u*y+u*y*z+y*z
--   </pre>
delta :: Polinomio -> Polinomio -> Variable -> Polinomio

-- | (delta' a1 a2 v) es el polinomio 1 + (1+b1*b2)*(1+(b1+c1)*(b2+c2))
--   donde ci es la derivada de ai respecto de v y bi es es el polinomio
--   formado por los monomios de ai que no contienen la variable x (para i
--   = 1, 2). Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; delta' (P[M["x","y"],M["y","z"]]) (P[M["u","x"],M["y","z"]]) "x"
--   u*y+u*y*z+y*z
--   </pre>
delta' :: Polinomio -> Polinomio -> Variable -> Polinomio

-- | Comprueba que las funciones delta y delta' son equivalentes.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_equiv_delta_delta'
--   +++ OK, passed 100 tests.
--   </pre>
prop_equiv_delta_delta' :: Polinomio -> Polinomio -> Bool

-- | (variablesMon m) es la lista de las variables del monomio m. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesMon (M ["x","z"])
--   ["x","z"]
--   </pre>
variablesMon :: Monomio -> [Variable]

-- | (variablesPol p) es la lista de las variables del polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; variablesPol (P[M["x","z"],M["y","z"]])
--   ["x","z","y"]
--   </pre>
variablesPol :: Polinomio -> [Variable]

-- | (deltaP f1 f2 v) es la f§ormula obtenida aplicando la regla delta (o
--   de independencia) a las fórmulas f1 y f2 respecto de la variable v.
--   Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaP (r → p ∨ q) (q → p ∧ q) "q"
--   ¬(⊤ ↔ ¬((p ∧ r) ↔ r))
--   </pre>
deltaP :: FProp -> FProp -> SimboloProposicional -> FProp

-- | Comprueba que la regla delta es adecuada: es decir que, para toda
--   fórmulas f1 y f2 y toda variable x de ellas, la fórmula (deltaP f1 f2
--   x) es consecuencia de f1 y f2.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_deltaP
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_deltaP :: FProp -> FProp -> Bool

-- | (pares xs) es la lista de los pares de elementos xs con el primero
--   menor o igual que el segundo. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; pares [1..4]
--   [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
--   </pre>
pares :: [a] -> [(a, a)]

-- | (derivadas ps x) es la lista de los polinomios obtenidos aplicando la
--   regla delta a dos polinomios de ps respecto de la variable x. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivadas [P[M["x","y"],M["y","z"]],P[M["a","y"],M["y"]]] "y"
--   [x+z,a*x+a*z+x+z,1+a]
--   </pre>
derivadas :: [Polinomio] -> Variable -> [Polinomio]

-- | (derivadasP fs x) es la lista de las proposiciones obtenidas aplicando
--   la regla deltaP a dos fórmulas de fs respecto de la variable x. Por
--   ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; derivadasP [p → q ∨ r, r → p] "q"
--   [¬(⊤ ↔ ¬((p ∧ r) ↔ r))]
--   
--   &gt;&gt;&gt; derivadasP [p → q ∨ r, r → q] "q"
--   []
--   </pre>
derivadasP :: [FProp] -> SimboloProposicional -> [FProp]

-- | (deltaRefutable ps) se verifica si ps es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutable [P[mUno,M["p"],M["p","q"]],P[M["p"]],P[mUno,M["q"]]]
--   True
--   
--   &gt;&gt;&gt; deltaRefutable [P[mUno,M["p"],M["p","q"]],P[M["p"]],P[mUno,M["r"]]]
--   False
--   </pre>
deltaRefutable :: [Polinomio] -> Bool

-- | (deltaRefutableP fs) se verifica si fs es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutableP [p → q, p, no q]
--   True
--   
--   &gt;&gt;&gt; deltaRefutableP [p → q, p, no r]
--   False
--   </pre>
deltaRefutableP :: [FProp] -> Bool

-- | (deltaRefutableP' fs) se verifica si fs es refutable mediante la regla
--   delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaRefutableP' [p → q, p, no q]
--   True
--   
--   &gt;&gt;&gt; deltaRefutableP' [p → q, p, no r]
--   False
--   </pre>
deltaRefutableP' :: [FProp] -> Bool

-- | Comprueba que las funciones deltaRefubleP y deltaRefutableP' son
--   equivalentes.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_def_alt_deltaRefutableP
--   +++ OK, passed 100 tests.
--   </pre>
prop_def_alt_deltaRefutableP :: [FProp] -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, para
--   todo conjunto de fórmulas fs, fs es inconsistente si y sólo si es
--   delta refutable.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_deltaP
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_deltaP :: [FProp] -> Bool

-- | (deltaDemostrable fs g) se verifica si g es demostrable a partir de fs
--   usando la regla delta. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaDemostrable [p → q, q → r] (p → r)
--   True
--   
--   &gt;&gt;&gt; deltaDemostrable [p → q, q → r] (r → p)
--   False
--   </pre>
deltaDemostrable :: [FProp] -> FProp -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, para
--   todo conjunto de fórmulas fs y toda fórmula g, g es consecuencia de fs
--   si y sólo si es g es delta demostrable a partir de fs.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_delta_2
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_delta_2 :: [FProp] -> FProp -> Bool

-- | (deltaTeorema f) se verifica si f es un teorema mediante la regla
--   delta; es decir, si la negación de f es delta refutable. Por ejemplo,
--   
--   <pre>
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (q → p))
--   True
--   
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (q → r))
--   True
--   
--   &gt;&gt;&gt; deltaTeorema ((p → q) ∨ (r → q))
--   False
--   </pre>
deltaTeorema :: FProp -> Bool

-- | Comprueba que la regla delta es adecuada y completa; es decir, que
--   para toda fórmula f, f es válida si y sólo si es un delta teorema.
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck prop_adecuacion_completitud_delta_3
--   +++ OK, passed 100 tests.
--   </pre>
prop_adecuacion_completitud_delta_3 :: FProp -> Bool
